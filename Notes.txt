Страница 28. Приведения типов крайне не рекомендуется делать в С. (Почему?).

Форум С сообщества: comp.lang.c, новостная лента: news:comp.lang.c.

Отступ 2 пробела вместо 4 - вполне себе стиль.

Страница 41.  Оператор return. Один из принципов структурного программирования состоит в том,
              что программа должна иметь одну точку входа и одну точку выхода. 
              Функции со многими операторами return более сложны для чтения, чем те,
              которые имеют лишь один оператор return в конце программы.
              Несколько точек выхода из подпрограммы следует использовать только в том случае,
              если это улучшит читаемость кода, а не наоборот.

Страница 42.  Чем более структурированно вы будете подходить к программированию, тем меньшее 
              количество ошибок будете получать при работе вашей программы. Более структурированный
              вам код читать очень легко. Код, который легко читать, является более простым для понимания,
              а значит, будет модифицирован скорее, чем трудный код, и в результате будет иметь
              значительно меньше ошибок.
             
Страница 46.  Любой идентификатор, который начинается с символа подчеркивания, за которым 
              следует либо буква в верхнем регистре, либо другой символ подчеркивания, 
              являются зарезервированными для использования в реализации компилятора.
              Безопаснее всего не начинать имена идентификаторов с символа подчеркивания.
             
              Список зарезервированных идентификаторов:
              [A-Z] означает любой символ алфавита в верхнем регистре;
              [0-9] означает любую цифру; 
              *(звездочка) означает все что угодно, и т.д.
             
              E[0-9]*
              LC[A-Z]*
              Offsetof
              str[a-z]*
              _*
              E[A-Z]*
              mem[a-z]*
              raise
              to[a-z]*
              is[a-z]*
              NDEBUG
              SIG[A-Z]*
              wcs[a-z]*
             
Страница 48.  Константы, типы и макросы - все эти объекты традиционно именуются 
              В ВЕРХНЕМ РЕГИСТРЕ.
             
Страница 50.  Нет необходимости добавлять комментарий в каждую строку кода. Если смысл
              выполняемых кодом действий ясен программисту сопровождения, не нужно его
              комментировать.
             
              Хорошие комментарии отражают то, для чего код предназначен (т.е. намерения
              программиста), а не сам механизм работы. Более того, механизм может время
              от времени меняться по мере того, как обнаруживаются усовершенствованные
              и новые способы выполнения той или иной операции.
             
              Когда ваши функции громоздки, бывает трудно определить, какая закрывающая 
              скобка } какой открывающей скобке { соответствует. Следовательно, в больших 
              программах необходимо позаботиться о комментировании ваших закрывающих скобок:
             
              if (IncomingMissile == TRUE)
              {
                  /* ... 20 строк кода  ...*/
                  while (PhaseOfMoon == FULL_MOON)
                  {
                     /* ... еще 40 строк кода ...*/
                  } /* конец блока while (PhaseOfMoon == FULL_MOON) */
              } /* конец блока if (IncomingMissile) */
             
             
Страница 53.  Функция main() обязательно должна возвращать int иначе
              возможно неопределенное поведение программы.
              Принимать функция main может либо два аргумента либо 0:
              int main() или int main(int argc, char** argv).
             
Страница 58.  Лучше не использовать функцию scanf() для интерактивного получения данных.
              Она предназначена для чтения ФОРМАТИРОВАННЫХ данных. Для сбора данных от пользователя,
              больше подходит функция fgets(). 
             
              Функциии из <ctype.h> (isupper, tolower и т.п.) принимают в качестве аргумента тип int, 
              но этот аргумент должен быть либо EOF, либо, значением, представленным как тип unsigned char.
              Любое другое значение вызовет неопределенное поведение. Если вы хотите полностью обезопасить
              эти функции, предварительно приведите их аргументы к типу unsigned char.
              Проблема возникает только тогда, когда ваша строка имеет символы, представленные вне 
              диапазона от 0 до UCHAR_MAX.
              Приведение к типу будет гарантировать безопасность операции, а компилятор позаботиться о том,
              чтобы значению вернуть тип int.
              
Страница 67.  В реальном мире ваша C - программа представляет собой коллекцию нескольких несвязанных 
              алгоритмов. Как установить O-нотацию для всей программы или для части программы, которую 
              используют многие алгоритмы?
              Во-первых, выясните, что представляется числом N в формуле О-нотации.
              Если вы передаете данные по сети, возможно, N - это число пересланных битов.
              Проверьте внутренние циклы основных частей своих алгоритмов и установите для этих 
              частей их индивидуальные О-нотации в соответствии с выбранными значениями N.
              
              Теперь скомбинируйте О-нотации различных частей своей программы и получите полное значение
              О-нотации программы. Имеется три способа комбинирования О-нотаций:
              
              - Последовательные операции. О-нотации двух алгоритмов складываются последовательно 
                одна за другой, и их общая О-нотация оказывается больше индивидульных. 
                Другими словами O(f(N)) в последовательности с O(g(N)) дает O(max(f(N), g(N))).
                Например, если f(N) больше g(N), то комбинированная О-нотация будет f(N).   
                
              - Вложенные операции. Когда алгоритм внутри себя содержит обращения к другому алгоритму, 
                результирующая О-нотация находится путем перемножения О-нотаций отдельных алгоритмов: 
                если O(f(N)) вызывает O(g(N)), то общая О-нотация будет равна O(f(N)*g(N)).	
                Например, если O(f(N)) была просто N (линейная), а O(g(N)) была N^2 (квадратичная), 
                то результирующая О-нотация двуя вложенных алгоритмов будет O(N^3).	
                
              - Параллельные опрерации. Комбинированая О-нотация двух алгоритмов, которые работают 
                параллельно, равна большей из О-нотаций каждого из алгоритмов:
                O(f(N)) паралельно с O(g(N)) дает O(max(f(N),g(N))).

Страница 112. Файлы бывают двух типов: текстовые и двоичные. В текстовых все данные предствалены
              как байты представляющие собой символы. 
              В двоичных файлах данные представлены примерно так же как в памяти программы.             
             
             
Страница 116. При чтении строковых данных функцией scanf() используя спецификатор %s, нужно быть
              аккуратным, т.к. считывание остановится на первом символе пробела(' ').
              Для чтения строк содержащих пробелы нужно использовать несколько более сложный спецификатор 
              (обычно это %[...]), либо вообще не использовать функции семейства scanf.
              
              Функции преобразования строкового(текстового) представления чисел в двоичный(кроме scanf):
                  atoi, strtol - short/int
                  atol, strtol - long
                  atof, strtod - float/double
                  strtoul - для переменной без знака.
                  
Страница 120. При работе с двоичными файлами в первую очередь их нужно правильно открывать. 
              Поскольку эти файлы по определению нетекстовые, нет нужды использовать стандартную 
              библиотеку Си для преобразования символов перевода каретки или окончания строки.
              Нет необходимости также рассматривать символ CTRL-Z как символ окончания файла в MS-DOS
              или Microsoft Windows. Чтобы библиотека stdio не делала преобразований таких символов,
              необходимо открывать файл в двоичном режиме, включив символ b в строку режима открытия 
              файла, которая является вторым аргументом, передаваемым функции fopen(). Таким образом
              чтобы открыть файл для чтения, нужно использовать rb, а чтобы открыть для записи, 
              нужно использовать wb.
              
              Если при работе с текстовыми файлами использут функции fprintf(), fscanf(), fgets(), 
              fputs() и т.д., то при работе с двоичными это fread() и fwrite().
              
              Целую величину i можно записать в двоичный файл, записав вызов следующим образом:
                  
                  fwrite(&i, sizeof(int), 1 ofp); 
              
              Эти функции предназначены для прямого копирования байтов данных из файла в память 
              и обратно. Их можно использовать и с текстовыми файлами, но чаще всего они 
              используются именно с двоичными файлами.
              
              Обе эти функции принимают указатель на некоторые данные, размер объекта данных
              (в байтах), количество элементов данных и указатель потока. 
              
              Расположение данных в файле, при использовании данной функции, один к одному повторяет 
              индивидуальную структуру этих данных в памяти компьютера. Из за чего структура файла 
              полностью зависит от любых особенностей платформы. Что несет за собой низкий уровень 
              переносимости.
              
              Различия в размере обьекта, в порядке байтов, в формате с плавающей точкой и структурк 
              заполнения приводят к тому, что двоичные файлы, записанные с использованием функции
              fwrite() на одном конкретном компьютере и с помощью одного конкретного компилятора, 
              могут не читаться на другом.
              
              В итоге можно сказать, что если файл должен быть переносимым, то методы чтения и записи 
              с использованием функций fread и fwrite в общем случае неприменимы.
              
Страница 121. Можно сделать так, чтобы чтение и запись двоичных файлов обадали переносимостью, но при 
              этом необходимо осуществлять более прямой контроль записи и чтения каждого отдельного 
              байта, а не доверять делать это компиятору.
              
              Основной метод заключается в обработке данных по одному байту. 
              
Страница 137. Использование различных компиляторов помогает высветить проблемы совместимости в вашей
              программе.
              
              Использование как минимум двух компиляторов, если это возможно, может иногда помощь
              убедить кого угодно (обычно вас самих), что конкретная проблема заключается в вашей 
              программе и что это не ошибка компилятора. В конце концов, очень сомнительно, что 
              два конкурирующих создателя компиляторов допустили совершенно одинаковые ошибки. 
              Кроме того, очень вероятно, что один компилятор снисходительнее другого.
 
Страница 140. Когда вы закончили (или думаете, что закончили) первый вариант любой нетривиальной 
              программы, можете держать пари, что она не в порядке. Верно сказано, что в каждой 
              нетривиальной программе есть хотя бы одна ошибка. Таким образом, отладка происходит 
              как до тестирования, так и после нее. И это, конечно, итерационный процесс. 	
              
              Когда вы впервые запустите свою программу, то вероятно, сразу заметите некоторые ошибки.
              Запишите их. Записывайте все неадекватности, котрорые заметите, независимо от того, 
              неожиданны они или планировались заранее. Естественной реакцией является исправление 
              первой же оплошности. Однако, сделав это, вы можете забыть об остальных замеченных проблемах,
              а они могут быть не столь явно видны при последующих выполнениях программы. Записывая их, 
              вы обеспечиваете себе шанс проверить все потенциально проблематичые места.
              
              
              Программу, сделанную в виде большой спутанной массы спагетти, полную переходов goto, 
              глобальных переменных и вызовов longjmp(), намного труднее отладить, чем тщательно разработанную
              модульную программу. Если программа разбита на модули, каждый из котрых отвечает за какой-то 
              определенный аспект работы программы, намного легче локализовать проблему, чем если ответствнность 
              за один и тот же процесс разделена между несколькими функциями или даже исходными файлами.
              
Страница 147. Многие C - программисты считают, что указатели и массивы - это одно и то же. Они действительно 
              имеют много общих свойств, но это не одно и то же. Путаница с указателями и массивами 
              может стать причиной ошибок.
              Например:
              
              int GetLoginNameFromUser(char *buffer)
              {
                int Result = 0;
                if( fgets(buffer, sizeof buffer, stdin) == NULL )
                {
                    Result = -1;
                }  
                return Result;
              }    
              
              Сложность этой ошибки заключается в том, что все выглядит корректно. Конструкция вызова 
              fgets будет прекрасно работать, только если buffer - это массив char. Это не так. Наиболее
              длинное имя пользователя, которое можно прочесть таким способом, имеет sizeof(char*) - 1 байтов.
              
                        
          

                  
                        
             
             
             
             
